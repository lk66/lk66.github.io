<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试4</title>
      <link href="/posts/8645.html"/>
      <url>/posts/8645.html</url>
      
        <content type="html"><![CDATA[<div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>～～～～～～～</p></div><span class='p center logo large'>数据结构</span><h1 id="练习题一"><a href="#练习题一" class="headerlink" title="练习题一"></a>练习题一</h1><details class="folding-tag" open><summary> 选择题 </summary>              <div class='content'>              <ol><li>线性结构中数据元素之间是（ ）关系。<br>A.一对多 B.多对多 C.多对一 D.一对一<br>答：<psw>D</psw></li><li>数据结构中与所使用的计算机无关的是数据的（ ）结构。<br>A.存储 B.物理 C.逻辑 D.物理和存储<br>答：<psw>C</psw></li><li>算法分析的目的是（ ）。<br>A.找出数据结构的合理性<br>B.研究算法中的输入和输出的关系<br>C.分析算法的效率以求改进<br>D.分析算法的易懂性和文档性<br>答：<psw>C</psw></li><li>算法分析的两个主要方面是（ ）。<br>A.空间复杂性和时间复杂性<br>B.正确性和简明性<br>C.可读性和文档性<br>D.数据复杂性和程序复杂性<br>答：<psw>A</psw></li><li>计算机算法指的是（ ）。<br>A.计算方法<br>B. 排序方法<br>C.求解问题的有限运算序列<br>D.调度方法<br>答：<psw>C</psw></li><li>计算机算法必须具备输入、输出和（ ）等 5 个特性。<br>A.可行性、可移植性和可扩充性<br>B.可行性、确定性和有穷性<br>C.确定性、有穷性和稳定性<br>D.易读性、稳定性和安全性<br>答：<psw>B</psw></li></ol>              </div>            </details><details class="folding-tag" ><summary> 填空题 </summary>              <div class='content'>              <ol><li><p>数据结构包括数据的 <psw>逻辑结构</psw> 、数据的 <psw>存储结构</psw> 和数据的 <psw>运算</psw> 这三个方面的内容。</p></li><li><p>数据结构按逻辑结构可分为两大类，它们分别是 <psw>线性结构</psw> 和 <psw>非线性结构</psw> 。</p></li><li><p>数据结构被形式地定义为（D,R），其中 D 是 <psw>数据元素</psw> 的有限集合，R 是 D 上的 <psw>关系</psw> 有限集合。</p></li><li><p>在<emp>线性结构</emp>中，第一个结点 <psw>没有</psw> 前驱结点，其余每个结点有且只有 1 个前驱结点；最后一个结点 <psw>没有</psw> 后继结点，其余每个结点有且只有 1 个后继结点。</p></li><li><p>在<emp>树形结构</emp>中，树根结点没有 <psw>前驱</psw> 结点，其余每个结点有且只有 <psw>1</psw> 个前驱结点；叶子结点没有 <psw>后继</psw> 结点，其余每个结点的后继结点数可以是 <psw>任意多个</psw> 。</p></li><li><p>在<emp>图形结构</emp>中，每个结点的前驱结点数和后继结点数可以是（ <psw>任意多个</psw> ）。</p></li><li><p>数据的存储结构主要有四种，它们分别是 <psw>顺序</psw> 、 <psw>链式</psw> 、 <psw>索引</psw> 和 <psw>哈希</psw> 存储结构。</p></li><li><p>一个算法的效率可分为 <psw>时间</psw> 效率和 <psw>空间</psw> 效率。</p></li></ol>              </div>            </details><details class="folding-tag" ><summary> 简答题 </summary>              <div class='content'>              <ol><li><p>数据结构和数据类型两个概念之间有区别吗？<br><psw>简单地说，数据结构定义了一组按某些关系结合在一起的数组元素的集合。数据类型不仅定义了一组数据元素，而且还在其上定义了一组操作。</psw></p></li><li><p>简述线性结构、树形结构和图形结构的不同点。<br><psw>线性结构反映结点间的逻辑关系是一对一的，树形线性结构反映结点间的逻辑关系是一对多的，图在结构反映结点间的逻辑关系是多对多的。</psw></p></li><li><p>设有采用二元组表示的数据逻辑结构 S&#x3D;(D,R)，其中 D&#x3D;{a,b,…,i}，R&#x3D;{(a,b),(a,c),(c,d),(c,f),(f,h),(d,e),(f,g),(h,i)}，问相对于关系 R，哪些结点是开始结点，哪些结点是终端结点？<br><psw>该逻辑结构为树形结构，其中 a 结点没有前驱结点，称为根结点，b、e、g、i 结点没有后继结点，是终端结点，也称为叶子结点。</psw></p></li><li><p>以下各函数是算法中语句的执行频度，n 为问题规模，给出对应的时间复杂度：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">T1(n)&#x3D;nlog2n-1000log2nT2(n)&#x3D;n的log2为底3次方-1000log2nT3(n)&#x3D;n2-1000log2nT4(n)&#x3D;2nlog2n-1000log2n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>T1(n)&#x3D;O(nlog2n)，T2(n)&#x3D;O(n的log2为底3次方)，T3(n)&#x3D;O(n2)，T4(n)&#x3D;O(nlog2n)。</psw></p><ol start="5"><li>分析下面程序段中循环语句的执行次数。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int j&#x3D;0,s&#x3D;0,n&#x3D;100;do&#123;   j&#x3D;j+1;   s&#x3D;s+10*j;&#125; while (j&lt;n &amp;&amp; s&lt;n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>j&#x3D;0，第 1 次循环：j&#x3D;1，s&#x3D;10。第 2 次循环：j&#x3D;2，s&#x3D;30。第 3 次循环：j&#x3D;3，s&#x3D;60。第 4 次循环：j&#x3D;4，s&#x3D;100。while 条件不再满足。所以，其中循环语句的执行次数为 4。</psw></p><ol start="6"><li>执行下面的语句时，语句 s++的执行次数为多少？</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int s&#x3D;0;for (i&#x3D;1;i&lt;n-1;i++)   for (j&#x3D;n;j&gt;&#x3D;i;j--)      s++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>语句 s 的执行次数。(n+3)(n-2)&#x2F;2</psw></p><ol start="7"><li>设 n 为问题规模，求以下算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun1(int n)&#123; int x&#x3D;0,i;for (i&#x3D;1;i&lt;&#x3D;n;i++)for (j&#x3D;i+1;j&lt;&#x3D;n;j++)x++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>其中 x++语句属基本运算语句，n(n-1)&#x2F;2&#x3D;O(n2)。</psw></p><ol start="8"><li>设 n 为问题规模，是一个正偶数，试计算以下算法结束时 m 的值，并给出该算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun2(int n)&#123;   int m&#x3D;0;   for (i&#x3D;1;i&lt;&#x3D;n;i++)      for (j&#x3D;2\*i;j&lt;&#x3D;n;j++)         m++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>由于内循环 j 的取值范围，所以 i≤n&#x2F;2，则m&#x3D;n的平方&#x2F;4，该程序段的时间复杂度为 O(n2)。</psw></p>              </div>            </details><h1 id="练习题二"><a href="#练习题二" class="headerlink" title="练习题二"></a>练习题二</h1><details class="folding-tag" open><summary> 选择题 </summary>              <div class='content'>              <ol><li>线性结构中数据元素之间是（ ）关系。<br>A.一对多 B.多对多 C.多对一 D.一对一<br>答：<psw>D</psw></li><li>数据结构中与所使用的计算机无关的是数据的（ ）结构。<br>A.存储 B.物理 C.逻辑 D.物理和存储<br>答：<psw>C</psw></li><li>算法分析的目的是（ ）。<br>A.找出数据结构的合理性<br>B.研究算法中的输入和输出的关系<br>C.分析算法的效率以求改进<br>D.分析算法的易懂性和文档性<br>答：<psw>C</psw></li><li>算法分析的两个主要方面是（ ）。<br>A.空间复杂性和时间复杂性<br>B.正确性和简明性<br>C.可读性和文档性<br>D.数据复杂性和程序复杂性<br>答：<psw>A</psw></li><li>计算机算法指的是（ ）。<br>A.计算方法<br>B. 排序方法<br>C.求解问题的有限运算序列<br>D.调度方法<br>答：<psw>C</psw></li><li>计算机算法必须具备输入、输出和（ ）等 5 个特性。<br>A.可行性、可移植性和可扩充性<br>B.可行性、确定性和有穷性<br>C.确定性、有穷性和稳定性<br>D.易读性、稳定性和安全性<br>答：<psw>B</psw></li></ol>              </div>            </details><details class="folding-tag" ><summary> 填空题 </summary>              <div class='content'>              <ol><li><p>数据结构包括数据的 <psw>逻辑结构</psw> 、数据的 <psw>存储结构</psw> 和数据的 <psw>运算</psw> 这三个方面的内容。</p></li><li><p>数据结构按逻辑结构可分为两大类，它们分别是 <psw>线性结构</psw> 和 <psw>非线性结构</psw> 。</p></li><li><p>数据结构被形式地定义为（D,R），其中 D 是 <psw>数据元素</psw> 的有限集合，R 是 D 上的 <psw>关系</psw> 有限集合。</p></li><li><p>在<emp>线性结构</emp>中，第一个结点 <psw>没有</psw> 前驱结点，其余每个结点有且只有 1 个前驱结点；最后一个结点 <psw>没有</psw> 后继结点，其余每个结点有且只有 1 个后继结点。</p></li><li><p>在<emp>树形结构</emp>中，树根结点没有 <psw>前驱</psw> 结点，其余每个结点有且只有 <psw>1</psw> 个前驱结点；叶子结点没有 <psw>后继</psw> 结点，其余每个结点的后继结点数可以是 <psw>任意多个</psw> 。</p></li><li><p>在<emp>图形结构</emp>中，每个结点的前驱结点数和后继结点数可以是（ <psw>任意多个</psw> ）。</p></li><li><p>数据的存储结构主要有四种，它们分别是 <psw>顺序</psw> 、 <psw>链式</psw> 、 <psw>索引</psw> 和 <psw>哈希</psw> 存储结构。</p></li><li><p>一个算法的效率可分为 <psw>时间</psw> 效率和 <psw>空间</psw> 效率。</p></li></ol>              </div>            </details><details class="folding-tag" ><summary> 简答题 </summary>              <div class='content'>              <ol><li><p>数据结构和数据类型两个概念之间有区别吗？<br><psw>简单地说，数据结构定义了一组按某些关系结合在一起的数组元素的集合。数据类型不仅定义了一组数据元素，而且还在其上定义了一组操作。</psw></p></li><li><p>简述线性结构、树形结构和图形结构的不同点。<br><psw>线性结构反映结点间的逻辑关系是一对一的，树形线性结构反映结点间的逻辑关系是一对多的，图在结构反映结点间的逻辑关系是多对多的。</psw></p></li><li><p>设有采用二元组表示的数据逻辑结构 S&#x3D;(D,R)，其中 D&#x3D;{a,b,…,i}，R&#x3D;{(a,b),(a,c),(c,d),(c,f),(f,h),(d,e),(f,g),(h,i)}，问相对于关系 R，哪些结点是开始结点，哪些结点是终端结点？<br><psw>该逻辑结构为树形结构，其中 a 结点没有前驱结点，称为根结点，b、e、g、i 结点没有后继结点，是终端结点，也称为叶子结点。</psw></p></li><li><p>以下各函数是算法中语句的执行频度，n 为问题规模，给出对应的时间复杂度：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">T1(n)&#x3D;nlog2n-1000log2nT2(n)&#x3D;n的log2为底3次方-1000log2nT3(n)&#x3D;n2-1000log2nT4(n)&#x3D;2nlog2n-1000log2n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>T1(n)&#x3D;O(nlog2n)，T2(n)&#x3D;O(n的log2为底3次方)，T3(n)&#x3D;O(n2)，T4(n)&#x3D;O(nlog2n)。</psw></p><ol start="5"><li>分析下面程序段中循环语句的执行次数。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int j&#x3D;0,s&#x3D;0,n&#x3D;100;do&#123;   j&#x3D;j+1;   s&#x3D;s+10*j;&#125; while (j&lt;n &amp;&amp; s&lt;n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>j&#x3D;0，第 1 次循环：j&#x3D;1，s&#x3D;10。第 2 次循环：j&#x3D;2，s&#x3D;30。第 3 次循环：j&#x3D;3，s&#x3D;60。第 4 次循环：j&#x3D;4，s&#x3D;100。while 条件不再满足。所以，其中循环语句的执行次数为 4。</psw></p><ol start="6"><li>执行下面的语句时，语句 s++的执行次数为多少？</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int s&#x3D;0;for (i&#x3D;1;i&lt;n-1;i++)   for (j&#x3D;n;j&gt;&#x3D;i;j--)      s++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>语句 s 的执行次数。(n+3)(n-2)&#x2F;2</psw></p><ol start="7"><li>设 n 为问题规模，求以下算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun1(int n)&#123; int x&#x3D;0,i;for (i&#x3D;1;i&lt;&#x3D;n;i++)for (j&#x3D;i+1;j&lt;&#x3D;n;j++)x++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>其中 x++语句属基本运算语句，n(n-1)&#x2F;2&#x3D;O(n2)。</psw></p><ol start="8"><li>设 n 为问题规模，是一个正偶数，试计算以下算法结束时 m 的值，并给出该算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun2(int n)&#123;   int m&#x3D;0;   for (i&#x3D;1;i&lt;&#x3D;n;i++)      for (j&#x3D;2\*i;j&lt;&#x3D;n;j++)         m++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>由于内循环 j 的取值范围，所以 i≤n&#x2F;2，则m&#x3D;n的平方&#x2F;4，该程序段的时间复杂度为 O(n2)。</psw></p>              </div>            </details><h1 id="练习题一-1"><a href="#练习题一-1" class="headerlink" title="练习题一"></a>练习题一</h1><details class="folding-tag" open><summary> 选择题 </summary>              <div class='content'>              <ol><li>线性结构中数据元素之间是（ ）关系。<br>A.一对多 B.多对多 C.多对一 D.一对一<br>答：<psw>D</psw></li><li>数据结构中与所使用的计算机无关的是数据的（ ）结构。<br>A.存储 B.物理 C.逻辑 D.物理和存储<br>答：<psw>C</psw></li><li>算法分析的目的是（ ）。<br>A.找出数据结构的合理性<br>B.研究算法中的输入和输出的关系<br>C.分析算法的效率以求改进<br>D.分析算法的易懂性和文档性<br>答：<psw>C</psw></li><li>算法分析的两个主要方面是（ ）。<br>A.空间复杂性和时间复杂性<br>B.正确性和简明性<br>C.可读性和文档性<br>D.数据复杂性和程序复杂性<br>答：<psw>A</psw></li><li>计算机算法指的是（ ）。<br>A.计算方法<br>B. 排序方法<br>C.求解问题的有限运算序列<br>D.调度方法<br>答：<psw>C</psw></li><li>计算机算法必须具备输入、输出和（ ）等 5 个特性。<br>A.可行性、可移植性和可扩充性<br>B.可行性、确定性和有穷性<br>C.确定性、有穷性和稳定性<br>D.易读性、稳定性和安全性<br>答：<psw>B</psw></li></ol>              </div>            </details><details class="folding-tag" ><summary> 填空题 </summary>              <div class='content'>              <ol><li><p>数据结构包括数据的 <psw>逻辑结构</psw> 、数据的 <psw>存储结构</psw> 和数据的 <psw>运算</psw> 这三个方面的内容。</p></li><li><p>数据结构按逻辑结构可分为两大类，它们分别是 <psw>线性结构</psw> 和 <psw>非线性结构</psw> 。</p></li><li><p>数据结构被形式地定义为（D,R），其中 D 是 <psw>数据元素</psw> 的有限集合，R 是 D 上的 <psw>关系</psw> 有限集合。</p></li><li><p>在<emp>线性结构</emp>中，第一个结点 <psw>没有</psw> 前驱结点，其余每个结点有且只有 1 个前驱结点；最后一个结点 <psw>没有</psw> 后继结点，其余每个结点有且只有 1 个后继结点。</p></li><li><p>在<emp>树形结构</emp>中，树根结点没有 <psw>前驱</psw> 结点，其余每个结点有且只有 <psw>1</psw> 个前驱结点；叶子结点没有 <psw>后继</psw> 结点，其余每个结点的后继结点数可以是 <psw>任意多个</psw> 。</p></li><li><p>在<emp>图形结构</emp>中，每个结点的前驱结点数和后继结点数可以是（ <psw>任意多个</psw> ）。</p></li><li><p>数据的存储结构主要有四种，它们分别是 <psw>顺序</psw> 、 <psw>链式</psw> 、 <psw>索引</psw> 和 <psw>哈希</psw> 存储结构。</p></li><li><p>一个算法的效率可分为 <psw>时间</psw> 效率和 <psw>空间</psw> 效率。</p></li></ol>              </div>            </details><details class="folding-tag" ><summary> 简答题 </summary>              <div class='content'>              <ol><li><p>数据结构和数据类型两个概念之间有区别吗？<br><psw>简单地说，数据结构定义了一组按某些关系结合在一起的数组元素的集合。数据类型不仅定义了一组数据元素，而且还在其上定义了一组操作。</psw></p></li><li><p>简述线性结构、树形结构和图形结构的不同点。<br><psw>线性结构反映结点间的逻辑关系是一对一的，树形线性结构反映结点间的逻辑关系是一对多的，图在结构反映结点间的逻辑关系是多对多的。</psw></p></li><li><p>设有采用二元组表示的数据逻辑结构 S&#x3D;(D,R)，其中 D&#x3D;{a,b,…,i}，R&#x3D;{(a,b),(a,c),(c,d),(c,f),(f,h),(d,e),(f,g),(h,i)}，问相对于关系 R，哪些结点是开始结点，哪些结点是终端结点？<br><psw>该逻辑结构为树形结构，其中 a 结点没有前驱结点，称为根结点，b、e、g、i 结点没有后继结点，是终端结点，也称为叶子结点。</psw></p></li><li><p>以下各函数是算法中语句的执行频度，n 为问题规模，给出对应的时间复杂度：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">T1(n)&#x3D;nlog2n-1000log2nT2(n)&#x3D;n的log2为底3次方-1000log2nT3(n)&#x3D;n2-1000log2nT4(n)&#x3D;2nlog2n-1000log2n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>T1(n)&#x3D;O(nlog2n)，T2(n)&#x3D;O(n的log2为底3次方)，T3(n)&#x3D;O(n2)，T4(n)&#x3D;O(nlog2n)。</psw></p><ol start="5"><li>分析下面程序段中循环语句的执行次数。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int j&#x3D;0,s&#x3D;0,n&#x3D;100;do&#123;   j&#x3D;j+1;   s&#x3D;s+10*j;&#125; while (j&lt;n &amp;&amp; s&lt;n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>j&#x3D;0，第 1 次循环：j&#x3D;1，s&#x3D;10。第 2 次循环：j&#x3D;2，s&#x3D;30。第 3 次循环：j&#x3D;3，s&#x3D;60。第 4 次循环：j&#x3D;4，s&#x3D;100。while 条件不再满足。所以，其中循环语句的执行次数为 4。</psw></p><ol start="6"><li>执行下面的语句时，语句 s++的执行次数为多少？</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int s&#x3D;0;for (i&#x3D;1;i&lt;n-1;i++)   for (j&#x3D;n;j&gt;&#x3D;i;j--)      s++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>语句 s 的执行次数。(n+3)(n-2)&#x2F;2</psw></p><ol start="7"><li>设 n 为问题规模，求以下算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun1(int n)&#123; int x&#x3D;0,i;for (i&#x3D;1;i&lt;&#x3D;n;i++)for (j&#x3D;i+1;j&lt;&#x3D;n;j++)x++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>其中 x++语句属基本运算语句，n(n-1)&#x2F;2&#x3D;O(n2)。</psw></p><ol start="8"><li>设 n 为问题规模，是一个正偶数，试计算以下算法结束时 m 的值，并给出该算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun2(int n)&#123;   int m&#x3D;0;   for (i&#x3D;1;i&lt;&#x3D;n;i++)      for (j&#x3D;2\*i;j&lt;&#x3D;n;j++)         m++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>由于内循环 j 的取值范围，所以 i≤n&#x2F;2，则m&#x3D;n的平方&#x2F;4，该程序段的时间复杂度为 O(n2)。</psw></p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术支持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试2</title>
      <link href="/posts/d4d2.html"/>
      <url>/posts/d4d2.html</url>
      
        <content type="html"><![CDATA[<span class='p center logo large'>操作系统</span><details class="folding-tag" open><summary> 选择题 </summary>              <div class='content'>              <ol><li><p>操作系统的最主要设计目标是（ ）。<br>A．方便性和有效性 B．方便性和可扩展性<br>C．有效性和可扩展性 D．有效性和开放性<br>答：<psw>A</psw></p></li><li><p>有甲、乙两道算题，每道需执行 1 小时（其中处理器的工作时间为 12 分钟）。若它们在多道系统中执行，甲、乙两道题总共需执行 80 分钟，则处理器的利用率为（ ）。<br>A．50% B．40% C．30% D．20%<br>答：<psw>C</psw></p></li><li><p>从下面对临界区的论述中，选出一条正确的论述。（ ）<br>A.临界区是指进程中用于实现进程同步的那段代码<br>B.临界区是指进程中用于实现进程通信的那段代码<br>C.临界区是指进程中用于访问共享资源的那段代码<br>D.临界区是指进程中访问临界资源的那段代码<br>答：<psw>D</psw></p></li><li><p>操作系统提供一组特殊的程序，它们不能被系统中断，在操作系统中称为（ ）。<br>A.初始化程序 B.原语 C.子程序 D.控制模块<br>答：<psw>B</psw></p></li><li><p>一种既有利于短小作业又兼顾到长作业的作业调度算法是（ ）。<br>A．先来先服务 B．轮转 C．最高响应比优先 D．均衡调度<br>答：<psw>C</psw></p></li><li><p>操作系统中，资源分配的基本单位是（ ）。<br>A．进程 B．线程 C．作业 D．程序<br>答：<psw>A</psw></p></li><li><p>进程之间的制约关系可以归结为（ ）。<br>A．同步与互斥 B．并发与异步 C．同步与并发 D．同步与异步<br>答：<psw>A</psw></p></li><li><p>产生死锁的原因是（ ）有关。<br>A．与多个进程竞争 CPU<br>B．与多个进程释放资源<br>C．仅由于并发进程的执行速度不当<br>D．除资源分配策略不当外，也与并发进程执行速度不当<br>答：<psw>D</psw></p></li><li><p>死锁的 4 个必要条件中，无法破坏的是（ ）。<br>A.环路等待资源 B.互斥使用资源 C.占有且等待资源 D.非抢夺式分配<br>答：<psw>B</psw></p></li><li><p>页式存储管理中，每次从主存中取指令或取操作数，当读快表失败时，要读（ ）次主存。<br>A．1 B．2 C．3 D．4<br>答：<psw>B</psw></p></li><li><p>中断和通道技术的引入，使得（ ）。<br>A．CPU 与外设能紧密结合 B．CPU 与外设能并行工作<br>C．CPU 速度提高 D．外设速度提高<br>答：<psw>B</psw></p></li><li><p>下列关于进程和线程的叙述中，正确的是（ ）<br>A．不管系统是否支持线程，进程都是资源分配的基本单位<br>B．线程是资源分配的基本单位，进程是调度的基本单位<br>C．系统级线程和用户级线程的切换都需要内核的支持<br>D．同一进程中的各个线程拥有各自不同的地址空间<br>答：<psw>A</psw></p></li><li><p>在下述进程状态的转换中，( ) 是不可能的。<br>A．运行态 → 就绪态 B．运行态 → 等待态 C．等待态 → 就绪态 D．就绪态 → 等待态<br>答：<psw>D</psw></p></li><li><p>若信号量 S 的初值为 2，当前值为-1，则表示有( )个等待进程。<br>A．0 B．1 C．2 D．3<br>答：<psw>B</psw></p></li><li><p>下列选项中，会导致进程从执行态变为就绪态的事件是（ ）。<br>A.执行 P 操作 B.申请内存失败 C.启动 I&#x2F;O 设备 D.被高优先级进程抢占<br>答：<psw>D</psw></p></li><li><p>将主存空闲区按地址顺序从小到大登记在空闲区表中，每次分配时总是顺序查找空闲区表，此种分配算法称为 ( ) 分配算法。<br>A．首次适应 B．最佳适应 C．最坏适应 D．循环首次适应<br>答：<psw>B</psw></p></li><li><p>系统为某进程分配了 4 个页框，该进程已访问的页号序列为 2、0、2、9、3、4、2、8、2、4、8、4、5。若进程要访问的下一页的页号为 7，依据 LRU 算法，应淘汰页的页号是（ ）。<br>A. 2 B. 3 C. 4 D. 8<br>答：<psw>A</psw></p></li><li><p>按文件的组织方式可将文件分成 （ ） 等。<br>A．数据文件，命令文件，文本文件<br>B．命令文件，库文件，索引文件<br>C．顺序文件，索引文件，索引顺序文件<br>D．输入文件，输出文件，随机文件<br>答：<psw>C</psw></p></li><li><p>并发性是指若干事件在（ ）发生。<br>A.同一时刻 B.不同时刻 C.同一时间间隔内 D.不同时间间隔内<br>答：<psw>C</psw></p></li><li><p>设与某资源相关联的信号量初值为 3，当前值为 1，若 M 表示该资源的可用个数，N 表示等待资源的进程数，则 M、N 分别是（ ）。<br>A. 0、1 B. 1、0 C. 1、2 D. 2、0<br>答：<psw>B</psw></p></li><li><p>在对记录型信号量的 P 操作的定义中，当信号量的值（ ）时，执行 P 操作的进程变为阻塞状态。<br>A.大于 0<br>B.小于 0<br>C.等于 0<br>D.小于或等于 0<br>答：<psw>B</psw></p></li><li><p>系统中有 4 个进程都要使用某类资源。若每个进程最多需要 3 个该类资源，为保证系统不发生死锁，系统应提供该类资源至少是（ ）。<br>A.3 个 B.4 个 C.9 个 D.12 个<br>答：<psw>C</psw></p></li><li><p>采用分页存储管理方式进行存储分配时产生的存储碎片，被称为（ ）。<br>A.外零头 B.内零头 C.外零头或内零头 D.A、B、C 都正确<br>答：<psw>D</psw></p></li><li><p>进程和程序的本质区别是（ ）。<br>A.前者是动态的，后者是静态的<br>B.前者存储在内存，后者存储在外存<br>C.前者在一个文件中，后者在多个文件中<br>D.前者分时使用 CPU，后者独占 CPU<br>答：<psw>A</psw></p></li><li><p>分页存储管理系统中，虚拟地址转换成物理地址的工作是由（ ）完成的。<br>A.地址转换程序 B.用户程序 C.硬件 D.装入程序<br>答：<psw>C</psw></p></li><li><p>一个作业 8:00 到达系统，估计运行时间为 1 小时。若 10:00 开始执行该作业，其响应比是（ ）。<br>A.2<br>B.1<br>C.3<br>D.0.5<br>答：<psw>C， 响应比定义为：响应比&#x3D;作业响应时间&#x2F;运行时问的估计值。其中响应时间为作业进入系统后的等待时间加上估计的运行时间。于是响应比&#x3D;1+作业等待时间&#x2F;运行时间的估计值。所以本题计算*: 1+(10-8)&#x2F;1&#x3D;3,</psw></p></li><li><p>具有 3 级页表的系统中，访问内存的次数为（ ）。<br>A.4<br>B.3<br>C.2<br>D.1<br>答：<psw>A</psw></p></li></ol>              </div>            </details><details class="folding-tag" open><summary> 填空题 </summary>              <div class='content'>              <ol><li><p>设有四个作业同时到达，每个作业的执行时间均为 1 小时，它们在一台处理机上按单道方式运行，则平均周转时间为<psw>2.5</psw>小时。</p></li><li><p>在 OS 中，不可中断的操作称为<psw>原语</psw>。</p></li><li><p>如果系统中有 n 个进程，则在等待队列中进程的个数最多为 <psw>n</psw>个。</p></li><li><p>操作系统是一种<psw>系统</psw>软件。</p></li><li><p>一次仅允许一个进程使用的资源称为<psw>临界资源</psw>。</p></li><li><p>操作系统的接口有<psw>命令接口</psw>、程序接口和图形用户接口。</p></li><li><p>操作系统中的 SPOOLing 技术，实质是将<psw>独占</psw>设备转化为共享设备的技术。</p></li><li><p>设备 I&#x2F;O 方式有如下三种：程序方式、中断方式、<psw>询问</psw>和通道工作方式。</p></li><li><p>现代操作系统应当具备的特征为<psw>程序的并发执行</psw>、资源共享、<psw>操作的</psw>异步。</p></li></ol>              </div>            </details><details class="folding-tag" open><summary> 简答题 </summary>              <div class='content'>              <ol><li><p>画出进程的五种状态转换图并注明转换的条件。</p><div class="hide-block"><button type="button" class="hide-button" style="">答案 </button><div class="hide-content"><p><img src="https://img02.anzhiy.cn/adminuploads/1/2023/02/07/63e1dd4b3942a.png"></p></div></div></li><li><p>简述分页和分段的主要区别。</p><div class="hide-block"><button type="button" class="hide-button" style="">答案 </button><div class="hide-content"><blockquote><p>主要的区别如下：</p><ol><li>单位：分页是以固定页面大小（通常为 4KB 或 8KB）为单位进行内存分配的，而分段则是以程序段为单位进行内存分配的。</li><li>粒度：分页的粒度较小，适合管理大量小数据块，而分段的粒度较大，适合管理较大的数据段。</li><li>空间利用率：分页可以有效利用内存空间，因为它可以将内存块进行细粒度的分配，而分段则存在内存碎片问题。</li><li>管理方式：分页通常由操作系统自动完成，而分段则需要程序员手动实现。</li><li>总体来说，分页适用于管理大量小数据块，分段适用于管理大块内存。操作系统根据需求选择使用分页或分段，或者两者结合使用。</li></ol></blockquote></div></div></li><li><p>在操作系统中引起进程调度的因素有哪些？</p><div class="hide-block"><button type="button" class="hide-button" style="">答案 </button><div class="hide-content"><blockquote><ol><li>进程状态：当进程进入就绪状态，即可以运行，操作系统就会考虑是否进行调度。</li><li>优先级：操作系统会根据进程的优先级来选择哪个进程先运行。</li><li>CPU 时间片：操作系统通常使用时间片轮转算法，从而选择哪个进程先运行。</li><li>I&#x2F;O 操作：当进程在等待 I&#x2F;O 操作完成时，操作系统可以将 CPU 资源分配给其他进程。</li><li>进程睡眠：当进程处于睡眠状态，操作系统可以将 CPU 资源分配给其他进程。</li></ol></blockquote></div></div></li><li><p>（1）描述访问临界资源的循环进程（2）写出同步机制应遵循的准则</p><div class="hide-block"><button type="button" class="hide-button" style="">答案 </button><div class="hide-content"><blockquote><p>访问临界资源的循环进程是指多个进程同时对一个共享资源进行读写操作。由于多个进程同时竞争这个资源，可能导致数据冲突、不一致等问题。</p></blockquote><blockquote><ul><li>互斥性：在任意时刻，最多只有一个进程可以访问共享资源。</li><li>占有且继续：当一个进程占有共享资源时，它不会释放该资源直到完成对其的操作。</li><li>不死锁：在任意时刻，系统不会发生死锁现象，即多个进程因互相等待对方释放资源而陷入僵局。</li><li>有限等待：系统保证每个进程最多等待一个固定的时间限制，在该时间限制内，如果共享资源仍未被释放，则该进程被强制剥夺其占用资源的权利。</li><li>公平性：系统必须保证每个进程在等待共享资源的同时，都有相同的机会获得资源，不存在某个进程长期占有资源的情况。</li></ul></blockquote></div></div></li><li><p>简述死锁产生的原因及必要条件。</p><div class="hide-block"><button type="button" class="hide-button" style="">答案 </button><div class="hide-content"><blockquote><p>死锁是指两个或更多的进程在执行过程中因竞争资源而造成的一种互相等待的现象，若无外力作用将无法推进下去。死锁产生的必要条件包括：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：进程已经占有了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能强行剥夺。</li><li>循环等待条件：存在一个进程等待序列，使得每个进程等待的其他进程正在等待该进程所占有的资源，形成一个环。</li></ol><p>当满足以上四个条件时，就会发生死锁。</p></blockquote></div></div></li></ol>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 大学生涯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试1</title>
      <link href="/posts/1234.html"/>
      <url>/posts/1234.html</url>
      
        <content type="html"><![CDATA[<div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>～～～～～～～</p></div><span class='p center logo large'>数据结构</span><h1 id="练习题一"><a href="#练习题一" class="headerlink" title="练习题一"></a>练习题一</h1><details class="folding-tag" open><summary> 选择题 </summary>              <div class='content'>              <ol><li>线性结构中数据元素之间是（ ）关系。<br>A.一对多 B.多对多 C.多对一 D.一对一<br>答：<psw>D</psw></li><li>数据结构中与所使用的计算机无关的是数据的（ ）结构。<br>A.存储 B.物理 C.逻辑 D.物理和存储<br>答：<psw>C</psw></li><li>算法分析的目的是（ ）。<br>A.找出数据结构的合理性<br>B.研究算法中的输入和输出的关系<br>C.分析算法的效率以求改进<br>D.分析算法的易懂性和文档性<br>答：<psw>C</psw></li><li>算法分析的两个主要方面是（ ）。<br>A.空间复杂性和时间复杂性<br>B.正确性和简明性<br>C.可读性和文档性<br>D.数据复杂性和程序复杂性<br>答：<psw>A</psw></li><li>计算机算法指的是（ ）。<br>A.计算方法<br>B. 排序方法<br>C.求解问题的有限运算序列<br>D.调度方法<br>答：<psw>C</psw></li><li>计算机算法必须具备输入、输出和（ ）等 5 个特性。<br>A.可行性、可移植性和可扩充性<br>B.可行性、确定性和有穷性<br>C.确定性、有穷性和稳定性<br>D.易读性、稳定性和安全性<br>答：<psw>B</psw></li></ol>              </div>            </details><details class="folding-tag" ><summary> 填空题 </summary>              <div class='content'>              <ol><li><p>数据结构包括数据的 <psw>逻辑结构</psw> 、数据的 <psw>存储结构</psw> 和数据的 <psw>运算</psw> 这三个方面的内容。</p></li><li><p>数据结构按逻辑结构可分为两大类，它们分别是 <psw>线性结构</psw> 和 <psw>非线性结构</psw> 。</p></li><li><p>数据结构被形式地定义为（D,R），其中 D 是 <psw>数据元素</psw> 的有限集合，R 是 D 上的 <psw>关系</psw> 有限集合。</p></li><li><p>在<emp>线性结构</emp>中，第一个结点 <psw>没有</psw> 前驱结点，其余每个结点有且只有 1 个前驱结点；最后一个结点 <psw>没有</psw> 后继结点，其余每个结点有且只有 1 个后继结点。</p></li><li><p>在<emp>树形结构</emp>中，树根结点没有 <psw>前驱</psw> 结点，其余每个结点有且只有 <psw>1</psw> 个前驱结点；叶子结点没有 <psw>后继</psw> 结点，其余每个结点的后继结点数可以是 <psw>任意多个</psw> 。</p></li><li><p>在<emp>图形结构</emp>中，每个结点的前驱结点数和后继结点数可以是（ <psw>任意多个</psw> ）。</p></li><li><p>数据的存储结构主要有四种，它们分别是 <psw>顺序</psw> 、 <psw>链式</psw> 、 <psw>索引</psw> 和 <psw>哈希</psw> 存储结构。</p></li><li><p>一个算法的效率可分为 <psw>时间</psw> 效率和 <psw>空间</psw> 效率。</p></li></ol>              </div>            </details><details class="folding-tag" ><summary> 简答题 </summary>              <div class='content'>              <ol><li><p>数据结构和数据类型两个概念之间有区别吗？<br><psw>简单地说，数据结构定义了一组按某些关系结合在一起的数组元素的集合。数据类型不仅定义了一组数据元素，而且还在其上定义了一组操作。</psw></p></li><li><p>简述线性结构、树形结构和图形结构的不同点。<br><psw>线性结构反映结点间的逻辑关系是一对一的，树形线性结构反映结点间的逻辑关系是一对多的，图在结构反映结点间的逻辑关系是多对多的。</psw></p></li><li><p>设有采用二元组表示的数据逻辑结构 S&#x3D;(D,R)，其中 D&#x3D;{a,b,…,i}，R&#x3D;{(a,b),(a,c),(c,d),(c,f),(f,h),(d,e),(f,g),(h,i)}，问相对于关系 R，哪些结点是开始结点，哪些结点是终端结点？<br><psw>该逻辑结构为树形结构，其中 a 结点没有前驱结点，称为根结点，b、e、g、i 结点没有后继结点，是终端结点，也称为叶子结点。</psw></p></li><li><p>以下各函数是算法中语句的执行频度，n 为问题规模，给出对应的时间复杂度：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">T1(n)&#x3D;nlog2n-1000log2nT2(n)&#x3D;n的log2为底3次方-1000log2nT3(n)&#x3D;n2-1000log2nT4(n)&#x3D;2nlog2n-1000log2n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>T1(n)&#x3D;O(nlog2n)，T2(n)&#x3D;O(n的log2为底3次方)，T3(n)&#x3D;O(n2)，T4(n)&#x3D;O(nlog2n)。</psw></p><ol start="5"><li>分析下面程序段中循环语句的执行次数。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int j&#x3D;0,s&#x3D;0,n&#x3D;100;do&#123;   j&#x3D;j+1;   s&#x3D;s+10*j;&#125; while (j&lt;n &amp;&amp; s&lt;n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>j&#x3D;0，第 1 次循环：j&#x3D;1，s&#x3D;10。第 2 次循环：j&#x3D;2，s&#x3D;30。第 3 次循环：j&#x3D;3，s&#x3D;60。第 4 次循环：j&#x3D;4，s&#x3D;100。while 条件不再满足。所以，其中循环语句的执行次数为 4。</psw></p><ol start="6"><li>执行下面的语句时，语句 s++的执行次数为多少？</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int s&#x3D;0;for (i&#x3D;1;i&lt;n-1;i++)   for (j&#x3D;n;j&gt;&#x3D;i;j--)      s++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>语句 s 的执行次数。(n+3)(n-2)&#x2F;2</psw></p><ol start="7"><li>设 n 为问题规模，求以下算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun1(int n)&#123; int x&#x3D;0,i;for (i&#x3D;1;i&lt;&#x3D;n;i++)for (j&#x3D;i+1;j&lt;&#x3D;n;j++)x++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>其中 x++语句属基本运算语句，n(n-1)&#x2F;2&#x3D;O(n2)。</psw></p><ol start="8"><li>设 n 为问题规模，是一个正偶数，试计算以下算法结束时 m 的值，并给出该算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun2(int n)&#123;   int m&#x3D;0;   for (i&#x3D;1;i&lt;&#x3D;n;i++)      for (j&#x3D;2\*i;j&lt;&#x3D;n;j++)         m++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>由于内循环 j 的取值范围，所以 i≤n&#x2F;2，则m&#x3D;n的平方&#x2F;4，该程序段的时间复杂度为 O(n2)。</psw></p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术支持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试3</title>
      <link href="/posts/8645.html"/>
      <url>/posts/8645.html</url>
      
        <content type="html"><![CDATA[<div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>～～～～～～～</p></div><span class='p center logo large'>数据结构</span><h1 id="练习题一"><a href="#练习题一" class="headerlink" title="练习题一"></a>练习题一</h1><details class="folding-tag" open><summary> 选择题 </summary>              <div class='content'>              <ol><li>线性结构中数据元素之间是（ ）关系。<br>A.一对多 B.多对多 C.多对一 D.一对一<br>答：<psw>D</psw></li><li>数据结构中与所使用的计算机无关的是数据的（ ）结构。<br>A.存储 B.物理 C.逻辑 D.物理和存储<br>答：<psw>C</psw></li><li>算法分析的目的是（ ）。<br>A.找出数据结构的合理性<br>B.研究算法中的输入和输出的关系<br>C.分析算法的效率以求改进<br>D.分析算法的易懂性和文档性<br>答：<psw>C</psw></li><li>算法分析的两个主要方面是（ ）。<br>A.空间复杂性和时间复杂性<br>B.正确性和简明性<br>C.可读性和文档性<br>D.数据复杂性和程序复杂性<br>答：<psw>A</psw></li><li>计算机算法指的是（ ）。<br>A.计算方法<br>B. 排序方法<br>C.求解问题的有限运算序列<br>D.调度方法<br>答：<psw>C</psw></li><li>计算机算法必须具备输入、输出和（ ）等 5 个特性。<br>A.可行性、可移植性和可扩充性<br>B.可行性、确定性和有穷性<br>C.确定性、有穷性和稳定性<br>D.易读性、稳定性和安全性<br>答：<psw>B</psw></li></ol>              </div>            </details><details class="folding-tag" ><summary> 填空题 </summary>              <div class='content'>              <ol><li><p>数据结构包括数据的 <psw>逻辑结构</psw> 、数据的 <psw>存储结构</psw> 和数据的 <psw>运算</psw> 这三个方面的内容。</p></li><li><p>数据结构按逻辑结构可分为两大类，它们分别是 <psw>线性结构</psw> 和 <psw>非线性结构</psw> 。</p></li><li><p>数据结构被形式地定义为（D,R），其中 D 是 <psw>数据元素</psw> 的有限集合，R 是 D 上的 <psw>关系</psw> 有限集合。</p></li><li><p>在<emp>线性结构</emp>中，第一个结点 <psw>没有</psw> 前驱结点，其余每个结点有且只有 1 个前驱结点；最后一个结点 <psw>没有</psw> 后继结点，其余每个结点有且只有 1 个后继结点。</p></li><li><p>在<emp>树形结构</emp>中，树根结点没有 <psw>前驱</psw> 结点，其余每个结点有且只有 <psw>1</psw> 个前驱结点；叶子结点没有 <psw>后继</psw> 结点，其余每个结点的后继结点数可以是 <psw>任意多个</psw> 。</p></li><li><p>在<emp>图形结构</emp>中，每个结点的前驱结点数和后继结点数可以是（ <psw>任意多个</psw> ）。</p></li><li><p>数据的存储结构主要有四种，它们分别是 <psw>顺序</psw> 、 <psw>链式</psw> 、 <psw>索引</psw> 和 <psw>哈希</psw> 存储结构。</p></li><li><p>一个算法的效率可分为 <psw>时间</psw> 效率和 <psw>空间</psw> 效率。</p></li></ol>              </div>            </details><details class="folding-tag" ><summary> 简答题 </summary>              <div class='content'>              <ol><li><p>数据结构和数据类型两个概念之间有区别吗？<br><psw>简单地说，数据结构定义了一组按某些关系结合在一起的数组元素的集合。数据类型不仅定义了一组数据元素，而且还在其上定义了一组操作。</psw></p></li><li><p>简述线性结构、树形结构和图形结构的不同点。<br><psw>线性结构反映结点间的逻辑关系是一对一的，树形线性结构反映结点间的逻辑关系是一对多的，图在结构反映结点间的逻辑关系是多对多的。</psw></p></li><li><p>设有采用二元组表示的数据逻辑结构 S&#x3D;(D,R)，其中 D&#x3D;{a,b,…,i}，R&#x3D;{(a,b),(a,c),(c,d),(c,f),(f,h),(d,e),(f,g),(h,i)}，问相对于关系 R，哪些结点是开始结点，哪些结点是终端结点？<br><psw>该逻辑结构为树形结构，其中 a 结点没有前驱结点，称为根结点，b、e、g、i 结点没有后继结点，是终端结点，也称为叶子结点。</psw></p></li><li><p>以下各函数是算法中语句的执行频度，n 为问题规模，给出对应的时间复杂度：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">T1(n)&#x3D;nlog2n-1000log2nT2(n)&#x3D;n的log2为底3次方-1000log2nT3(n)&#x3D;n2-1000log2nT4(n)&#x3D;2nlog2n-1000log2n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>T1(n)&#x3D;O(nlog2n)，T2(n)&#x3D;O(n的log2为底3次方)，T3(n)&#x3D;O(n2)，T4(n)&#x3D;O(nlog2n)。</psw></p><ol start="5"><li>分析下面程序段中循环语句的执行次数。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int j&#x3D;0,s&#x3D;0,n&#x3D;100;do&#123;   j&#x3D;j+1;   s&#x3D;s+10*j;&#125; while (j&lt;n &amp;&amp; s&lt;n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>j&#x3D;0，第 1 次循环：j&#x3D;1，s&#x3D;10。第 2 次循环：j&#x3D;2，s&#x3D;30。第 3 次循环：j&#x3D;3，s&#x3D;60。第 4 次循环：j&#x3D;4，s&#x3D;100。while 条件不再满足。所以，其中循环语句的执行次数为 4。</psw></p><ol start="6"><li>执行下面的语句时，语句 s++的执行次数为多少？</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int s&#x3D;0;for (i&#x3D;1;i&lt;n-1;i++)   for (j&#x3D;n;j&gt;&#x3D;i;j--)      s++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><psw>语句 s 的执行次数。(n+3)(n-2)&#x2F;2</psw></p><ol start="7"><li>设 n 为问题规模，求以下算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun1(int n)&#123; int x&#x3D;0,i;for (i&#x3D;1;i&lt;&#x3D;n;i++)for (j&#x3D;i+1;j&lt;&#x3D;n;j++)x++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>其中 x++语句属基本运算语句，n(n-1)&#x2F;2&#x3D;O(n2)。</psw></p><ol start="8"><li>设 n 为问题规模，是一个正偶数，试计算以下算法结束时 m 的值，并给出该算法的时间复杂度。</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun2(int n)&#123;   int m&#x3D;0;   for (i&#x3D;1;i&lt;&#x3D;n;i++)      for (j&#x3D;2\*i;j&lt;&#x3D;n;j++)         m++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><psw>由于内循环 j 的取值范围，所以 i≤n&#x2F;2，则m&#x3D;n的平方&#x2F;4，该程序段的时间复杂度为 O(n2)。</psw></p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术支持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣1219:黄金矿工</title>
      <link href="/posts/9f16.html"/>
      <url>/posts/9f16.html</url>
      
        <content type="html"><![CDATA[<p>2022年02月05日 力扣每日一题</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为&nbsp;<code>m * n</code> 的网格 <code>grid</code> 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 <code>0</code>。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><ul>    <li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li>    <li>矿工每次可以从当前位置向上下左右四个方向走。</li>    <li>每个单元格只能被开采（进入）一次。</li>    <li><strong>不得开采</strong>（进入）黄金数目为 <code>0</code> 的单元格。</li>    <li>矿工可以从网格中 <strong>任意一个</strong> 有黄金的单元格出发或者是停止。</li></ul><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>grid = [[0,6,0],[5,8,7],[0,9,0]]<strong>输出：</strong>24<strong>解释：</strong>[[0,6,0], [5,8,7], [0,9,0]]一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]<strong>输出：</strong>28<strong>解释：</strong>[[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]]一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= grid.length,&nbsp;grid[i].length &lt;= 15</code></li>    <li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>    <li>最多 <strong>25 </strong>个单元格中有黄金。</li></ul><div><div>Related Topics</div><div><li>数组</li><li>回溯</li><li>矩阵</li></div></div><h1 id="个人解法"><a href="#个人解法" class="headerlink" title="个人解法"></a>个人解法</h1><div class="tabs" id="categories"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#categories-1">Java</button></li><li class="tab"><button type="button" data-href="#categories-2">Python3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="categories-1"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> xl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> yl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMaximumGold</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> counts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> use <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>grid<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                use<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                counts <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>counts<span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> grid<span class="token punctuation">,</span> use<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                use<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> counts<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> use<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> counts <span class="token operator">=</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> xl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> yl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nx <span class="token operator">>=</span> grid<span class="token punctuation">.</span>length <span class="token operator">||</span> ny <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> ny <span class="token operator">>=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">||</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> use<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            use<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            counts <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>counts<span class="token punctuation">,</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">dfs</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">,</span> grid<span class="token punctuation">,</span> use<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            use<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> counts<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="categories-2"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">getMaximumGold</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>            count <span class="token operator">=</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span>            <span class="token keyword">for</span> nx<span class="token punctuation">,</span> ny <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> nx <span class="token operator">>=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token keyword">or</span> ny <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> ny <span class="token operator">>=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">or</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> use<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                use<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                count <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span> dfs<span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span><span class="token punctuation">)</span>                use<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token keyword">return</span> count        counts <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 这种形式下，给一个元素赋值，对应的所有行相同列都会赋值</span>        <span class="token comment"># use = [[False] * len(grid[0])] * len(grid)</span>        use <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                    use<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>                    counts <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>counts<span class="token punctuation">,</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span>                    use<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> counts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 力扣 </category>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
